<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>2048小游戏</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            overflow-x: hidden;
            touch-action: manipulation;
        }

        .container {
            max-width: 100vw;
            min-height: 100vh;
            padding: 10px;
        }

        .header {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 15px 20px;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
        }

        .title {
            font-size: 24px;
            font-weight: bold;
            color: #333;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }

        .time {
            font-size: 18px;
            color: #666;
            font-weight: 500;
        }

        .menu {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .menu-btn {
            background: rgba(255, 255, 255, 0.95);
            border: none;
            border-radius: 20px;
            padding: 25px 20px;
            font-size: 18px;
            font-weight: 600;
            color: #333;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            text-align: center;
            min-height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1.4;
        }

        .menu-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
            background: rgba(255, 255, 255, 1);
        }

        .menu-btn:active {
            transform: translateY(-1px);
        }

        .game-container {
            display: none;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            margin-bottom: 20px;
        }

        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .back-btn {
            background: #ff6b6b;
            color: white;
            border: none;
            border-radius: 10px;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .back-btn:hover {
            background: #ff5252;
            transform: translateY(-2px);
        }

        .score {
            font-size: 20px;
            font-weight: bold;
            color: #333;
        }

        .game-board {
            background: #bbada0;
            border-radius: 10px;
            padding: 10px;
            position: relative;
            touch-action: none;
        }

        .grid-container {
            display: grid;
            gap: 10px;
        }

        .grid-cell {
            background: rgba(238, 228, 218, 0.35);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: #776e65;
            transition: all 0.15s ease-in-out;
        }

        .tile {
            position: absolute;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            transition: all 0.1s ease-in-out;
            font-size: clamp(16px, 4vw, 32px);
        }

        .ai-battle-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }

        .player-section {
            background: rgba(255, 255, 255, 0.9);
            border-radius: 15px;
            padding: 15px;
            text-align: center;
        }

        .player-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #333;
        }

        .four-ai-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 20px;
        }

        .ai-section {
            background: rgba(255, 255, 255, 0.9);
            border-radius: 15px;
            padding: 15px;
            text-align: center;
        }

        .ai-name {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #333;
        }

        @media (max-width: 768px) {
            .title {
                font-size: 20px;
            }
            
            .time {
                font-size: 16px;
            }
            
            .menu {
                grid-template-columns: 1fr;
            }
            
            .menu-btn {
                font-size: 16px;
                padding: 20px 15px;
                min-height: 80px;
            }
            
            .ai-battle-container {
                grid-template-columns: 1fr;
            }
            
            .four-ai-container {
                grid-template-columns: 1fr;
            }
        }

        .win-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.98);
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            display: none;
        }

        .win-title {
            font-size: 28px;
            font-weight: bold;
            color: #333;
            margin-bottom: 20px;
        }

        .restart-btn {
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 10px;
            padding: 12px 30px;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .restart-btn:hover {
            background: #45a049;
            transform: translateY(-2px);
        }

        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 999;
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="title">2048小游戏</div>
            <div class="time" id="time"></div>
        </div>

        <div class="menu" id="menu">
            <button class="menu-btn" onclick="startGame('classic')">经典玩法<br><small>无限合成数字</small></button>
            <button class="menu-btn" onclick="startGame('ai-battle')">与AI对战<br><small>谁先合到2048获胜</small></button>
            <button class="menu-btn" onclick="startGame('watch-ai')">观看AI玩2048<br><small>AI自动游玩</small></button>
            <button class="menu-btn" onclick="startGame('watch-ai-50')">观看AI玩2048-50格版<br><small>50格棋盘</small></button>
            <button class="menu-btn" onclick="startGame('watch-4ai')">观看4个不同思维的AI<br><small>四种AI策略对战</small></button>
            <button class="menu-btn" onclick="startGame('turn-based')">你一步我一步<br><small>轮流操作模式</small></button>
        </div>

        <!-- 经典玩法 -->
        <div class="game-container" id="classic-game">
            <div class="game-header">
                <button class="back-btn" onclick="backToMenu()">返回</button>
                <div class="score">得分: <span id="classic-score">0</span></div>
            </div>
            <div class="game-board" id="classic-board"></div>
        </div>

        <!-- AI对战 -->
        <div class="game-container" id="ai-battle-game">
            <div class="game-header">
                <button class="back-btn" onclick="backToMenu()">返回</button>
                <div class="score" id="battle-status">与AI对战</div>
            </div>
            <div class="ai-battle-container">
                <div class="player-section">
                    <div class="player-title">玩家</div>
                    <div class="game-board" id="player-board"></div>
                </div>
                <div class="player-section">
                    <div class="player-title">AI</div>
                    <div class="game-board" id="ai-board"></div>
                </div>
            </div>
        </div>

        <!-- 观看AI -->
        <div class="game-container" id="watch-ai-game">
            <div class="game-header">
                <button class="back-btn" onclick="backToMenu()">返回</button>
                <div class="score">AI得分: <span id="watch-ai-score">0</span></div>
            </div>
            <div class="game-board" id="watch-ai-board"></div>
        </div>

        <!-- 观看AI-50格版 -->
        <div class="game-container" id="watch-ai-50-game">
            <div class="game-header">
                <button class="back-btn" onclick="backToMenu()">返回</button>
                <div class="score">AI得分: <span id="watch-ai-50-score">0</span></div>
            </div>
            <div class="game-board" id="watch-ai-50-board"></div>
        </div>

        <!-- 观看4个AI -->
        <div class="game-container" id="watch-4ai-game">
            <div class="game-header">
                <button class="back-btn" onclick="backToMenu()">返回</button>
                <div class="score" id="4ai-status">四个AI对战</div>
            </div>
            <div class="four-ai-container">
                <div class="ai-section">
                    <div class="ai-name">简单型AI</div>
                    <div class="game-board" id="ai1-board"></div>
                </div>
                <div class="ai-section">
                    <div class="ai-name">深度思考型AI</div>
                    <div class="game-board" id="ai2-board"></div>
                </div>
                <div class="ai-section">
                    <div class="ai-name">无脑型AI</div>
                    <div class="game-board" id="ai3-board"></div>
                </div>
                <div class="ai-section">
                    <div class="ai-name">顺序移动型AI</div>
                    <div class="game-board" id="ai4-board"></div>
                </div>
            </div>
        </div>

        <!-- 轮流对战 -->
        <div class="game-container" id="turn-based-game">
            <div class="game-header">
                <button class="back-btn" onclick="backToMenu()">返回</button>
                <div class="score" id="turn-status">你的回合</div>
            </div>
            <div class="ai-battle-container">
                <div class="player-section">
                    <div class="player-title">玩家</div>
                    <div class="game-board" id="turn-player-board"></div>
                </div>
                <div class="player-section">
                    <div class="player-title">AI</div>
                    <div class="game-board" id="turn-ai-board"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="overlay" id="overlay"></div>
    <div class="win-message" id="win-message">
        <div class="win-title" id="win-title">恭喜获胜！</div>
        <button class="restart-btn" onclick="restartGame()">重新开始</button>
    </div>

    <script>
        // 更新时间
        function updateTime() {
            const now = new Date();
            const timeStr = now.toLocaleString('zh-CN', {
                timeZone: 'Asia/Shanghai',
                hour12: false
            });
            document.getElementById('time').textContent = timeStr;
        }
        setInterval(updateTime, 1000);
        updateTime();

        // 游戏逻辑
        class Game2048 {
            constructor(size = 4) {
                this.size = size;
                this.board = [];
                this.score = 0;
                this.hasWon = false;
                this.init();
            }

            init() {
                this.board = Array(this.size).fill().map(() => Array(this.size).fill(0));
                this.score = 0;
                this.hasWon = false;
                this.addRandomTile();
                this.addRandomTile();
            }

            addRandomTile() {
                const emptyCells = [];
                for (let i = 0; i < this.size; i++) {
                    for (let j = 0; j < this.size; j++) {
                        if (this.board[i][j] === 0) {
                            emptyCells.push({x: i, y: j});
                        }
                    }
                }
                if (emptyCells.length > 0) {
                    const cell = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                    this.board[cell.x][cell.y] = Math.random() < 0.9 ? 2 : 4;
                }
            }

            move(direction) {
                let moved = false;
                const newBoard = this.board.map(row => [...row]);

                if (direction === 'left') {
                    for (let i = 0; i < this.size; i++) {
                        const row = newBoard[i].filter(cell => cell !== 0);
                        for (let j = 0; j < row.length - 1; j++) {
                            if (row[j] === row[j + 1]) {
                                row[j] *= 2;
                                this.score += row[j];
                                row.splice(j + 1, 1);
                                if (row[j] === 2048) this.hasWon = true;
                            }
                        }
                        while (row.length < this.size) row.push(0);
                        for (let j = 0; j < this.size; j++) {
                            if (newBoard[i][j] !== row[j]) moved = true;
                            newBoard[i][j] = row[j];
                        }
                    }
                } else if (direction === 'right') {
                    for (let i = 0; i < this.size; i++) {
                        const row = newBoard[i].filter(cell => cell !== 0).reverse();
                        for (let j = 0; j < row.length - 1; j++) {
                            if (row[j] === row[j + 1]) {
                                row[j] *= 2;
                                this.score += row[j];
                                row.splice(j + 1, 1);
                                if (row[j] === 2048) this.hasWon = true;
                            }
                        }
                        while (row.length < this.size) row.push(0);
                        row.reverse();
                        for (let j = 0; j < this.size; j++) {
                            if (newBoard[i][j] !== row[j]) moved = true;
                            newBoard[i][j] = row[j];
                        }
                    }
                } else if (direction === 'up') {
                    for (let j = 0; j < this.size; j++) {
                        const col = [];
                        for (let i = 0; i < this.size; i++) {
                            if (newBoard[i][j] !== 0) col.push(newBoard[i][j]);
                        }
                        for (let i = 0; i < col.length - 1; i++) {
                            if (col[i] === col[i + 1]) {
                                col[i] *= 2;
                                this.score += col[i];
                                col.splice(i + 1, 1);
                                if (col[i] === 2048) this.hasWon = true;
                            }
                        }
                        while (col.length < this.size) col.push(0);
                        for (let i = 0; i < this.size; i++) {
                            if (newBoard[i][j] !== col[i]) moved = true;
                            newBoard[i][j] = col[i];
                        }
                    }
                } else if (direction === 'down') {
                    for (let j = 0; j < this.size; j++) {
                        const col = [];
                        for (let i = this.size - 1; i >= 0; i--) {
                            if (newBoard[i][j] !== 0) col.push(newBoard[i][j]);
                        }
                        for (let i = 0; i < col.length - 1; i++) {
                            if (col[i] === col[i + 1]) {
                                col[i] *= 2;
                                this.score += col[i];
                                col.splice(i + 1, 1);
                                if (col[i] === 2048) this.hasWon = true;
                            }
                        }
                        while (col.length < this.size) col.push(0);
                        for (let i = this.size - 1; i >= 0; i--) {
                            if (newBoard[i][j] !== col[this.size - 1 - i]) moved = true;
                            newBoard[i][j] = col[this.size - 1 - i];
                        }
                    }
                }

                if (moved) {
                    this.board = newBoard;
                    this.addRandomTile();
                    return true;
                }
                return false;
            }

            canMove() {
                for (let i = 0; i < this.size; i++) {
                    for (let j = 0; j < this.size; j++) {
                        if (this.board[i][j] === 0) return true;
                        if (j < this.size - 1 && this.board[i][j] === this.board[i][j + 1]) return true;
                        if (i < this.size - 1 && this.board[i][j] === this.board[i + 1][j]) return true;
                    }
                }
                return false;
            }
        }

        // AI策略
        class AI {
            static simple(game) {
                const directions = ['left', 'up', 'right', 'down'];
                for (let dir of directions) {
                    const testGame = new Game2048(game.size);
                    testGame.board = game.board.map(row => [...row]);
                    if (testGame.move(dir)) return dir;
                }
                return directions[Math.floor(Math.random() * directions.length)];
            }

            static deepThink(game) {
                const directions = ['left', 'up', 'right', 'down'];
                let bestScore = -1;
                let bestDir = 'left';
                
                for (let dir of directions) {
                    const testGame = new Game2048(game.size);
                    testGame.board = game.board.map(row => [...row]);
                    if (testGame.move(dir)) {
                        let score = 0;
                        // 评估函数：考虑空格数、最大数位置、单调性等
                        for (let i = 0; i < testGame.size; i++) {
                            for (let j = 0; j < testGame.size; j++) {
                                if (testGame.board[i][j] === 0) score += 1;
                                // 角落奖励
                                if ((i === 0 || i === testGame.size - 1) && 
                                    (j === 0 || j === testGame.size - 1) && 
                                    testGame.board[i][j] > 0) {
                                    score += Math.log2(testGame.board[i][j]);
                                }
                            }
                        }
                        if (score > bestScore) {
                            bestScore = score;
                            bestDir = dir;
                        }
                    }
                }
                return bestDir;
            }

            static random(game) {
                const directions = ['left', 'up', 'right', 'down'];
                return directions[Math.floor(Math.random() * directions.length)];
            }

            static sequential(game, step) {
                const directions = ['left', 'up', 'right', 'down'];
                return directions[step % 4];
            }
        }

        // 渲染游戏板
        function renderBoard(game, containerId, size = 4) {
            const container = document.getElementById(containerId);
            const cellSize = Math.min(
                (container.parentElement.clientWidth - 40) / size,
                window.innerWidth > 768 ? 100 : 60
            );
            
            container.innerHTML = '';
            container.style.width = `${cellSize * size + 20}px`;
            container.style.height = `${cellSize * size + 20}px`;
            
            // 创建网格
            const grid = document.createElement('div');
            grid.className = 'grid-container';
            grid.style.gridTemplateColumns = `repeat(${size}, 1fr)`;
            grid.style.gridTemplateRows = `repeat(${size}, 1fr)`;
            grid.style.width = `${cellSize * size}px`;
            grid.style.height = `${cellSize * size}px`;
            
            for (let i = 0; i < size * size; i++) {
                const cell = document.createElement('div');
                cell.className = 'grid-cell';
                cell.style.width = `${cellSize - 10}px`;
                cell.style.height = `${cellSize - 10}px`;
                grid.appendChild(cell);
            }
            container.appendChild(grid);
            
            // 创建方块
            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    if (game.board[i][j] !== 0) {
                        const tile = document.createElement('div');
                        tile.className = 'tile';
                        tile.textContent = game.board[i][j];
                        tile.style.width = `${cellSize - 10}px`;
                        tile.style.height = `${cellSize - 10}px`;
                        tile.style.left = `${j * cellSize + 10}px`;
                        tile.style.top = `${i * cellSize + 10}px`;
                        tile.style.backgroundColor = getTileColor(game.board[i][j]);
                        tile.style.color = game.board[i][j] > 4 ? '#f9f6f2' : '#776e65';
                        tile.style.fontSize = `${Math.max(16, cellSize / 3)}px`;
                        container.appendChild(tile);
                    }
                }
            }
        }

        function getTileColor(value) {
            const colors = {
                2: '#eee4da', 4: '#ede0c8', 8: '#f2b179', 16: '#f59563',
                32: '#f67c5f', 64: '#f65e3b', 128: '#edcf72', 256: '#edcc61',
                512: '#edc850', 1024: '#edc53f', 2048: '#edc22e'
            };
            return colors[value] || '#3c3a32';
        }

        // 当前游戏状态
        let currentGame = null;
        let currentMode = null;
        let aiGames = [];
        let aiIntervals = [];

        // 开始游戏
        function startGame(mode) {
            currentMode = mode;
            document.getElementById('menu').style.display = 'none';
            
            // 清除之前的AI定时器
            aiIntervals.forEach(interval => clearInterval(interval));
            aiIntervals = [];
            
            switch(mode) {
                case 'classic':
                    currentGame = new Game2048();
                    document.getElementById('classic-game').style.display = 'block';
                    renderBoard(currentGame, 'classic-board');
                    setupTouchControls('classic-board', currentGame);
                    break;
                    
                case 'ai-battle':
                    const playerGame = new Game2048();
                    const aiGame = new Game2048();
                    currentGame = { player: playerGame, ai: aiGame };
                    document.getElementById('ai-battle-game').style.display = 'block';
                    renderBoard(playerGame, 'player-board');
                    renderBoard(aiGame, 'ai-board');
                    setupTouchControls('player-board', playerGame, () => {
                        if (!aiGame.hasWon && aiGame.canMove()) {
                            setTimeout(() => {
                                aiGame.move(AI.deepThink(aiGame));
                                renderBoard(aiGame, 'ai-board');
                                checkBattleWinner();
                            }, 300);
                        }
                    });
                    break;
                    
                case 'watch-ai':
                    currentGame = new Game2048();
                    document.getElementById('watch-ai-game').style.display = 'block';
                    renderBoard(currentGame, 'watch-ai-board');
                    const watchInterval = setInterval(() => {
                        if (currentGame.canMove()) {
                            currentGame.move(AI.deepThink(currentGame));
                            renderBoard(currentGame, 'watch-ai-board');
                            document.getElementById('watch-ai-score').textContent = currentGame.score;
                        }
                    }, 100);
                    aiIntervals.push(watchInterval);
                    break;
                    
                case 'watch-ai-50':
                    currentGame = new Game2048(5);
                    document.getElementById('watch-ai-50-game').style.display = 'block';
                    renderBoard(currentGame, 'watch-ai-50-board', 5);
                    const watch50Interval = setInterval(() => {
                        if (currentGame.canMove()) {
                            currentGame.move(AI.deepThink(currentGame));
                            renderBoard(currentGame, 'watch-ai-50-board', 5);
                            document.getElementById('watch-ai-50-score').textContent = currentGame.score;
                        }
                    }, 100);
                    aiIntervals.push(watch50Interval);
                    break;
                    
                case 'watch-4ai':
                    aiGames = [
                        new Game2048(),
                        new Game2048(),
                        new Game2048(),
                        new Game2048()
                    ];
                    document.getElementById('watch-4ai-game').style.display = 'block';
                    const boards = ['ai1-board', 'ai2-board', 'ai3-board', 'ai4-board'];
                    aiGames.forEach((game, index) => {
                        renderBoard(game, boards[index]);
                    });
                    
                    const fourAIInterval = setInterval(() => {
                        let hasWinner = false;
                        aiGames.forEach((game, index) => {
                            if (!game.hasWon 2;
                                this.score += col[i];
                                col.splice(i + 1, 1);
                                if (col[i] === 2048) this.hasWon = true;
                            }
                        }
                        while (col.length < this.size) col.push(0);
                        for (let i = this.size - 1; i >= 0; i--) {
                            if (newBoard[i][j] !== col[this.size - 1 - i]) moved = true;
                            newBoard[i][j] = col[this.size - 1 - i];
                        }
                    }
                }

                if (moved) {
                    this.board = newBoard;
                    this.addRandomTile();
                    return true;
                }
                return false;
            }

            canMove() {
                for (let i = 0; i < this.size; i++) {
                    for (let j = 0; j < this.size; j++) {
                        if (this.board[i][j] === 0) return true;
                        if (j < this.size - 1 && this.board[i][j] === this.board[i][j + 1]) return true;
                        if (i < this.size - 1 && this.board[i][j] === this.board[i + 1][j]) return true;
                    }
                }
                return false;
            }
        }

        // AI策略
        class AI {
            static simple(game) {
                const directions = ['left', 'up', 'right', 'down'];
                for (let dir of directions) {
                    const testGame = new Game2048(game.size);
                    testGame.board = game.board.map(row => [...row]);
                    if (testGame.move(dir)) return dir;
                }
                return directions[Math.floor(Math.random() * directions.length)];
            }

            static deepThink(game) {
                const directions = ['left', 'up', 'right', 'down'];
                let bestScore = -1;
                let bestDir = 'left';
                
                for (let dir of directions) {
                    const testGame = new Game2048(game.size);
                    testGame.board = game.board.map(row => [...row]);
                    if (testGame.move(dir)) {
                        let score = 0;
                        // 评估函数：考虑空格数、最大数位置、单调性等
                        for (let i = 0; i < testGame.size; i++) {
                            for (let j = 0; j < testGame.size; j++) {
                                if (testGame.board[i][j] === 0) score += 1;
                                // 角落奖励
                                if ((i === 0 || i === testGame.size - 1) && 
                                    (j === 0 || j === testGame.size - 1) && 
                                    testGame.board[i][j] > 0) {
                                    score += Math.log2(testGame.board[i][j]);
                                }
                            }
                        }
                        if (score > bestScore) {
                            bestScore = score;
                            bestDir = dir;
                        }
                    }
                }
                return bestDir;
            }

            static random(game) {
                const directions = ['left', 'up', 'right', 'down'];
                return directions[Math.floor(Math.random() * directions.length)];
            }

            static sequential(game, step) {
                const directions = ['left', 'up', 'right', 'down'];
                return directions[step % 4];
            }
        }

        // 渲染游戏板
        function renderBoard(game, containerId, size = 4) {
            const container = document.getElementById(containerId);
            const cellSize = Math.min(
                (container.parentElement.clientWidth - 40) / size,
                window.innerWidth > 768 ? 100 : 60
            );
            
            container.innerHTML = '';
            container.style.width = `${cellSize * size + 20}px`;
            container.style.height = `${cellSize * size + 20}px`;
            
            // 创建网格
            const grid = document.createElement('div');
            grid.className = 'grid-container';
            grid.style.gridTemplateColumns = `repeat(${size}, 1fr)`;
            grid.style.gridTemplateRows = `repeat(${size}, 1fr)`;
            grid.style.width = `${cellSize * size}px`;
            grid.style.height = `${cellSize * size}px`;
            
            for (let i = 0; i < size * size; i++) {
                const cell = document.createElement('div');
                cell.className = 'grid-cell';
                cell.style.width = `${cellSize - 10}px`;
                cell.style.height = `${cellSize - 10}px`;
                grid.appendChild(cell);
            }
            container.appendChild(grid);
            
            // 创建方块
            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    if (game.board[i][j] !== 0) {
                        const tile = document.createElement('div');
                        tile.className = 'tile';
                        tile.textContent = game.board[i][j];
                        tile.style.width = `${cellSize - 10}px`;
                        tile.style.height = `${cellSize - 10}px`;
                        tile.style.left = `${j * cellSize + 10}px`;
                        tile.style.top = `${i * cellSize + 10}px`;
                        tile.style.backgroundColor = getTileColor(game.board[i][j]);
                        tile.style.color = game.board[i][j] > 4 ? '#f9f6f2' : '#776e65';
                        tile.style.fontSize = `${Math.max(16, cellSize / 3)}px`;
                        container.appendChild(tile);
                    }
                }
            }
        }

        function getTileColor(value) {
            const colors = {
                2: '#eee4da', 4: '#ede0c8', 8: '#f2b179', 16: '#f59563',
                32: '#f67c5f', 64: '#f65e3b', 128: '#edcf72', 256: '#edcc61',
                512: '#edc850', 1024: '#edc53f', 2048: '#edc22e'
            };
            return colors[value] || '#3c3a32';
        }

        // 当前游戏状态
        let currentGame = null;
        let currentMode = null;
        let aiGames = [];
        let aiIntervals = [];

        // 开始游戏
        function startGame(mode) {
            currentMode = mode;
            document.getElementById('menu').style.display = 'none';
            
            // 清除之前的AI定时器
            aiIntervals.forEach(interval => clearInterval(interval));
            aiIntervals = [];
            
            switch(mode) {
                case 'classic':
                    currentGame = new Game2048();
                    document.getElementById('classic-game').style.display = 'block';
                    renderBoard(currentGame, 'classic-board');
                    setupTouchControls('classic-board', currentGame);
                    break;
                    
                case 'ai-battle':
                    const playerGame = new Game2048();
                    const aiGame = new Game2048();
                    currentGame = { player: playerGame, ai: aiGame };
                    document.getElementById('ai-battle-game').style.display = 'block';
                    renderBoard(playerGame, 'player-board');
                    renderBoard(aiGame, 'ai-board');
                    setupTouchControls('player-board', playerGame, () => {
                        if (!aiGame.hasWon && aiGame.canMove()) {
                            setTimeout(() => {
                                aiGame.move(AI.deepThink(aiGame));
                                renderBoard(aiGame, 'ai-board');
                                checkBattleWinner();
                            }, 300);
                        }
                    });
                    break;
                    
                case 'watch-ai':
                    currentGame = new Game2048();
                    document.getElementById('watch-ai-game').style.display = 'block';
                    renderBoard(currentGame, 'watch-ai-board');
                    const watchInterval = setInterval(() => {
                        if (currentGame.canMove()) {
                            currentGame.move(AI.deepThink(currentGame));
                            renderBoard(currentGame, 'watch-ai-board');
                            document.getElementById('watch-ai-score').textContent = currentGame.score;
                        }
                    }, 100);
                    aiIntervals.push(watchInterval);
                    break;
                    
                case 'watch-ai-50':
                    currentGame = new Game2048(5);
                    document.getElementById('watch-ai-50-game').style.display = 'block';
                    renderBoard(currentGame, 'watch-ai-50-board', 5);
                    const watch50Interval = setInterval(() => {
                        if (currentGame.canMove()) {
                            currentGame.move(AI.deepThink(currentGame));
                            renderBoard(currentGame, 'watch-ai-50-board', 5);
                            document.getElementById('watch-ai-50-score').textContent = currentGame.score;
                        }
                    }, 100);
                    aiIntervals.push(watch50Interval);
                    break;
                    
                case 'watch-4ai':
                    aiGames = [
                        new Game2048(),
                        new Game2048(),
                        new Game2048(),
                        new Game2048()
                    ];
                    document.getElementById('watch-4ai-game').style.display = 'block';
                    const boards = ['ai1-board', 'ai2-board', 'ai3-board', 'ai4-board'];
                    aiGames.forEach((game, index) => {
                        renderBoard(game, boards[index]);
                    });
                    
                    const fourAIInterval = setInterval(() => {
                        let hasWinner = false;
                        aiGames.forEach((game, index) => {
                            if (!game.hasWon && game.canMove()) {
                                let move;
                                switch(index) {
                                    case 0: move = AI.simple(game); break;
                                    case 1: move = AI.deepThink(game); break;
                                    case 2: move = AI.random(game); break;
                                    case 3: move = AI.sequential(game, Date.now()); break;
                                }
                                game.move(move);
                                renderBoard(game, boards[index]);
                                if (game.hasWon) {
                                    hasWinner = true;
                                    document.getElementById('4ai-status').textContent = 
                                        `AI${index + 1} (${['简单型', '深度思考型', '无脑型', '顺序移动型'][index]}) 获胜！`;
                                }
                            }
                        });
                        if (hasWinner) {
                            clearInterval(fourAIInterval);
                        }
                    }, 200);
                    aiIntervals.push(fourAIInterval);
                    break;
                    
                case 'turn-based':
                    const turnPlayerGame = new Game2048();
                    const turnAIGame = new Game2048();
                    currentGame = { player: turnPlayerGame, ai: turnAIGame, playerTurn: true };
                    document.getElementById('turn-based-game').style.display = 'block';
                    renderBoard(turnPlayerGame, 'turn-player-board');
                    renderBoard(turnAIGame, 'turn-ai-board');
                    setupTouchControls('turn-player-board', turnPlayerGame, () => {
                        if (currentGame.playerTurn && turnAIGame.canMove()) {
                            currentGame.playerTurn = false;
                            document.getElementById('turn-status').textContent = 'AI回合';
                            setTimeout(() => {
                                turnAIGame.move(AI.deepThink(turnAIGame));
                                renderBoard(turnAIGame, 'turn-ai-board');
                                currentGame.playerTurn = true;
                                document.getElementById('turn-status').textContent = '你的回合';
                            }, 500);
                        }
                    });
                    break;
            }
        }

        // 返回菜单
        function backToMenu() {
            document.querySelectorAll('.game-container').forEach(el => el.style.display = 'none');
            document.getElementById('menu').style.display = 'grid';
            aiIntervals.forEach(interval => clearInterval(interval));
            aiIntervals = [];
            currentGame = null;
            currentMode = null;
        }

        // 设置触摸控制
        function setupTouchControls(boardId, game, callback) {
            const board = document.getElementById(boardId);
            let startX, startY;
            
            board.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                startY = e.touches[0].clientY;
            }, { passive: true });
            
            board.addEventListener('touchend', (e) => {
                if (!startX || !startY) return;
                
                const endX = e.changedTouches[0].clientX;
                const endY = e.changedTouches[0].clientY;
                
                const diffX = endX - startX;
                const diffY = endY - startY;
                
                if (Math.abs(diffX) > Math.abs(diffY)) {
                    if (diffX > 30 && game.move('right')) {
                        renderBoard(game, boardId, game.size);
                        if (callback) callback();
                    } else if (diffX < -30 && game.move('left')) {
                        renderBoard(game, boardId, game.size);
                        if (callback) callback();
                    }
                } else {
                    if (diffY > 30 && game.move('down')) {
                        renderBoard(game, boardId, game.size);
                        if (callback) callback();
                    } else if (diffY < -30 && game.move('up')) {
                        renderBoard(game, boardId, game.size);
                        if (callback) callback();
                    }
                }
                
                startX = null;
                startY = null;
            }, { passive: true });
            
            // 键盘控制
            document.addEventListener('keydown', (e) => {
                if (currentMode !== 'classic' && !currentMode?.includes('battle')) return;
                
                let moved = false;
                switch(e.key) {
                    case 'ArrowLeft': moved = game.move('left'); break;
                    case 'ArrowRight': moved = game.move('right'); break;
                    case 'ArrowUp': moved = game.move('up'); break;
                    case 'ArrowDown': moved = game.move('down'); break;
                }
                
                if (moved) {
                    renderBoard(game, boardId, game.size);
                    if (callback) callback();
                    if (currentMode === 'classic') {
                        document.getElementById('classic-score').textContent = game.score;
                        if (game.hasWon) showWinMessage('恭喜！你合成了2048！');
                    }
                }
            });
        }

        // 检查对战获胜者
        function checkBattleWinner() {
            if (currentGame.player.hasWon) {
                showWinMessage('你赢了！');
                aiIntervals.forEach(interval => clearInterval(interval));
            } else if (currentGame.ai.hasWon) {
                showWinMessage('AI赢了！');
                aiIntervals.forEach(interval => clearInterval(interval));
            }
        }

        // 显示获胜消息
        function showWinMessage(message) {
            document.getElementById('win-title').textContent = message;
            document.getElementById('overlay').style.display = 'block';
            document.getElementById('win-message').style.display = 'block';
        }

        // 重新开始
        function restartGame() {
            document.getElementById('overlay').style.display = 'none';
            document.getElementById('win-message').style.display = 'none';
            if (currentMode) {
                startGame(currentMode);
            }
        }

        // 防止页面滚动
        document.addEventListener('touchmove', function(e) {
            if (e.target.closest('.game-board')) {
                e.preventDefault();
            }
        }, { passive: false });
    </script>
</body>
</html>
